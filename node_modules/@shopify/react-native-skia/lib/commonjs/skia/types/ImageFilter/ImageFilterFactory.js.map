{"version":3,"names":["ColorChannel","exports"],"sources":["ImageFilterFactory.ts"],"sourcesContent":["import type { SkColor } from \"../Color\";\nimport type { SkColorFilter } from \"../ColorFilter/ColorFilter\";\nimport type { FilterMode, MipmapMode, SkImage } from \"../Image/Image\";\nimport type { SkMatrix } from \"../Matrix\";\nimport type { BlendMode } from \"../Paint\";\nimport type { SkPicture } from \"../Picture\";\nimport type { SkRect } from \"../Rect\";\nimport type { SkRuntimeShaderBuilder } from \"../RuntimeEffect\";\nimport type { SkShader } from \"../Shader\";\n\nimport type { SkImageFilter, TileMode } from \"./ImageFilter\";\n\nexport enum ColorChannel {\n  R,\n  G,\n  B,\n  A,\n}\n\nexport interface ImageFilterFactory {\n  /**\n   * Offsets the input image\n   *\n   * @param dx - Offset along the X axis\n   * @param dy - Offset along the X axis\n   * @param input - if null, it will use the dynamic source image\n   * @param cropRect - Optional rectangle that crops the input and output\n   */\n  MakeOffset(\n    dx: number,\n    dy: number,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n  /**\n   * Spatially displace pixel values of the filtered image\n   *\n   * @param channelX - Color channel to be used along the X axis\n   * @param channelY - Color channel to be used along the Y axis\n   * @param scale - Scale factor to be used in the displacement\n   * @param in1 - Source image filter to use for the displacement\n   * @param input - if null, it will use the dynamic source image\n   * @param cropRect - Optional rectangle that crops the input and output\n   */\n  MakeDisplacementMap(\n    channelX: ColorChannel,\n    channelY: ColorChannel,\n    scale: number,\n    in1: SkImageFilter,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n  /**\n   * Transforms a shader into an impage filter\n   *\n   * @param shader - The Shader to be transformed\n   * @param dither - Whether to apply dithering to the shader\n   * @param cropRect - Optional rectangle that crops the input and output\n   */\n  MakeShader(\n    shader: SkShader,\n    dither?: boolean,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n  /**\n   * Create a filter that blurs its input by the separate X and Y sigmas. The provided tile mode\n   * is used when the blur kernel goes outside the input image.\n   *\n   * @param sigmaX - The Gaussian sigma value for blurring along the X axis.\n   * @param sigmaY - The Gaussian sigma value for blurring along the Y axis.\n   * @param mode - The tile mode to use when blur kernel goes outside the image\n   * @param input - if null, it will use the dynamic source image (e.g. a saved layer)\n   * @param cropRect - Optional rectangle that crops the input and output\n   */\n  MakeBlur(\n    sigmaX: number,\n    sigmaY: number,\n    mode: TileMode,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n\n  /**\n   * Create a filter that applies the color filter to the input filter results.\n   *\n   * @param colorFilter - The color filter to apply\n   * @param input - if null, it will use the dynamic source image (e.g. a saved layer)\n   * @param cropRect - Optional rectangle that crops the input and output\n   */\n  MakeColorFilter(\n    colorFilter: SkColorFilter,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n\n  /**\n   * Create a filter that composes 'inner' with 'outer', such that the results of 'inner' are\n   * treated as the source bitmap passed to 'outer'.\n   * If either param is null, the other param will be returned.\n   * @param outer\n   * @param inner - if null, it will use the dynamic source image (e.g. a saved layer)\n   */\n  MakeCompose(\n    outer: SkImageFilter | null,\n    inner: SkImageFilter | null\n  ): SkImageFilter;\n\n  /**\n   * Create a filter that draws a drop shadow under the input content.\n   * This filter produces an image that includes the inputs' content.\n   * @param dx The X offset of the shadow.\n   * @param dy\tThe Y offset of the shadow.\n   * @param sigmaX\tThe blur radius for the shadow, along the X axis.\n   * @param sigmaY\tThe blur radius for the shadow, along the Y axis.\n   * @param color\tThe color of the drop shadow.\n   * @param input\tThe input filter, or will use the source bitmap if this is null.\n   * @param cropRect\tOptional rectangle that crops the input and output.\n   */\n  MakeDropShadow: (\n    dx: number,\n    dy: number,\n    sigmaX: number,\n    sigmaY: number,\n    color: SkColor,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ) => SkImageFilter;\n  /**\n   * Create a filter that renders a drop shadow, in exactly the same manner as ::DropShadow, except\n   * that the resulting image does not include the input content.\n   * This allows the shadow and input to be composed by a filter DAG in a more flexible manner.\n   * @param dx The X offset of the shadow.\n   * @param dy\tThe Y offset of the shadow.\n   * @param sigmaX\tThe blur radius for the shadow, along the X axis.\n   * @param sigmaY\tThe blur radius for the shadow, along the Y axis.\n   * @param color\tThe color of the drop shadow.\n   * @param input\tThe input filter, or will use the source bitmap if this is null.\n   * @param cropRect\tOptional rectangle that crops the input and output.\n   */\n  MakeDropShadowOnly: (\n    dx: number,\n    dy: number,\n    sigmaX: number,\n    sigmaY: number,\n    color: SkColor,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ) => SkImageFilter;\n  /**\n   *  Create a filter that erodes each input pixel's channel values to the minimum channel value\n   *  within the given radii along the x and y axes.\n   *  @param radiusX  The distance to erode along the x axis to either side of each pixel.\n   *  @param radiusY  The distance to erode along the y axis to either side of each pixel.\n   *  @param input    The image filter that is eroded, using source bitmap if this is null.\n   *  @param cropRect Optional rectangle that crops the input and output.\n   */\n  MakeErode: (\n    rx: number,\n    ry: number,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ) => SkImageFilter;\n  /**\n   *  Create a filter that dilates each input pixel's channel values to the max value within the\n   *  given radii along the x and y axes.\n   *  @param radiusX  The distance to dilate along the x axis to either side of each pixel.\n   *  @param radiusY  The distance to dilate along the y axis to either side of each pixel.\n   *  @param input    The image filter that is dilated, using source bitmap if this is null.\n   *  @param cropRect Optional rectangle that crops the input and output.\n   */\n  MakeDilate: (\n    rx: number,\n    ry: number,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ) => SkImageFilter;\n  /**\n   *  This filter takes an SkBlendMode and uses it to composite the two filters together.\n   *  @param mode       The blend mode that defines the compositing operation\n   *  @param background The Dst pixels used in blending, if null the source bitmap is used.\n   *  @param foreground The Src pixels used in blending, if null the source bitmap is used.\n   *  @param cropRect   Optional rectangle to crop input and output.\n   */\n  MakeBlend: (\n    mode: BlendMode,\n    background: SkImageFilter,\n    foreground?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ) => SkImageFilter;\n  /**\n   *  Create a filter that fills the output with the per-pixel evaluation of the SkShader produced\n   *  by the SkRuntimeShaderBuilder. The shader is defined in the image filter's local coordinate\n   *  system, so it will automatically be affected by SkCanvas' transform.\n   *\n   *  @param builder         The builder used to produce the runtime shader, that will in turn\n   *                         fill the result image\n   *  @param childShaderName The name of the child shader defined in the builder that will be\n   *                         bound to the input param (or the source image if the input param\n   *                         is null).  If null the builder can have exactly one child shader,\n   *                         which automatically binds the input param.\n   *  @param input           The image filter that will be provided as input to the runtime\n   *                         shader. If null the implicit source image is used instead\n   */\n  MakeRuntimeShader: (\n    builder: SkRuntimeShaderBuilder,\n    childShaderName: string | null,\n    input?: SkImageFilter | null\n  ) => SkImageFilter;\n\n  /**\n   *  Create a filter that implements a custom blend mode. Each output pixel is the result of\n   *  combining the corresponding background and foreground pixels using the 4 coefficients:\n   *     k1 * foreground * background + k2 * foreground + k3 * background + k4\n   *\n   *  @param k1, k2, k3, k4 The four coefficients used to combine the foreground and background.\n   *  @param enforcePMColor If true, the RGB channels will be clamped to the calculated alpha.\n   *  @param background     The background content, using the source bitmap when this is null.\n   *  @param foreground     The foreground content, using the source bitmap when this is null.\n   *  @param cropRect       Optional rectangle that crops the inputs and output.\n   */\n  MakeArithmetic(\n    k1: number,\n    k2: number,\n    k3: number,\n    k4: number,\n    enforcePMColor: boolean,\n    background?: SkImageFilter | null,\n    foreground?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n\n  /**\n   *  Create a filter that applies a crop to the result of the 'input' filter. Pixels within the\n   *  crop rectangle are unmodified from what 'input' produced. Pixels outside of crop match the\n   *  provided SkTileMode (defaulting to kDecal).\n   *\n   *  NOTE: The optional CropRect argument for many of the factories is equivalent to creating the\n   *  filter without a CropRect and then wrapping it in ::Crop(rect, kDecal). Explicitly adding\n   *  Crop filters lets you control their tiling and use different geometry for the input and the\n   *  output of another filter.\n   *\n   *  @param rect     The cropping rect\n   *  @param tileMode The TileMode applied to pixels *outside* of 'crop' @default TileMode.Decal\n   *  @param input    The input filter that is cropped, uses source image if this is null\n   */\n  MakeCrop(\n    rect: SkRect,\n    tileMode?: TileMode | null,\n    input?: SkImageFilter | null\n  ): SkImageFilter;\n\n  /**\n   * Create a filter that always produces transparent black.\n   */\n  MakeEmpty(): SkImageFilter;\n\n  /**\n   *  Create a filter that draws the 'srcRect' portion of image into 'dstRect' using the given\n   *  filter quality. Similar to SkCanvas::drawImageRect. The returned image filter evaluates\n   *  to transparent black if 'image' is null.\n   *\n   *  @param image      The image that is output by the filter, subset by 'srcRect'.\n   *  @param srcRect    The source pixels sampled into 'dstRect', if null the image bounds are used.\n   *  @param dstRect    The local rectangle to draw the image into, if null the srcRect is used.\n   *  @param filterMode The filter mode to use when sampling the image @default FilterMode.Nearest\n   *  @param mipmap     The mipmap mode to use when sampling the image @default MipmapMode.None\n   */\n  MakeImage(\n    image: SkImage,\n    srcRect?: SkRect | null,\n    dstRect?: SkRect | null,\n    filterMode?: FilterMode,\n    mipmap?: MipmapMode\n  ): SkImageFilter;\n\n  /**\n   *  Create a filter that fills 'lensBounds' with a magnification of the input.\n   *\n   *  @param lensBounds The outer bounds of the magnifier effect\n   *  @param zoomAmount The amount of magnification applied to the input image\n   *  @param inset      The size or width of the fish-eye distortion around the magnified content\n   *  @param filterMode The filter mode to use when sampling the image @default FilterMode.Nearest\n   *  @param mipmap     The mipmap mode to use when sampling the image @default MipmapMode.None\n   *  @param input      The input filter that is magnified; if null the source bitmap is used\n   *  @param cropRect   Optional rectangle that crops the input and output.\n   */\n  MakeMagnifier(\n    lensBounds: SkRect,\n    zoomAmount: number,\n    inset: number,\n    filterMode?: FilterMode,\n    mipmap?: MipmapMode,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n\n  /**\n   *  Create a filter that applies an NxM image processing kernel to the input image. This can be\n   *  used to produce effects such as sharpening, blurring, edge detection, etc.\n   *  @param kernelSizeX   The width of the kernel. Must be greater than zero.\n   *  @param kernelSizeY   The height of the kernel. Must be greater than zero.\n   *  @param kernel        The image processing kernel. Must contain kernelSizeX * kernelSizeY elements, in row order.\n   *  @param gain          A scale factor applied to each pixel after convolution. This can be\n   *                       used to normalize the kernel, if it does not already sum to 1.\n   *  @param bias          A bias factor added to each pixel after convolution.\n   *  @param kernelOffsetX An offset applied to each pixel coordinate before convolution.\n   *                       This can be used to center the kernel over the image\n   *                       (e.g., a 3x3 kernel should have an offset of {1, 1}).\n   *  @param kernelOffsetY An offset applied to each pixel coordinate before convolution.\n   *                       This can be used to center the kernel over the image\n   *                       (e.g., a 3x3 kernel should have an offset of {1, 1}).\n   *  @param tileMode      How accesses outside the image are treated. TileMode.Mirror is not supported.\n   *  @param convolveAlpha If true, all channels are convolved. If false, only the RGB channels\n   *                       are convolved, and alpha is copied from the source image.\n   *  @param input         The input image filter, if null the source bitmap is used instead.\n   *  @param cropRect      Optional rectangle to which the output processing will be limited.\n   */\n  MakeMatrixConvolution(\n    kernelSizeX: number,\n    kernelSizeY: number,\n    kernel: number[],\n    gain: number,\n    bias: number,\n    kernelOffsetX: number,\n    kernelOffsetY: number,\n    tileMode: TileMode,\n    convolveAlpha: boolean,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n\n  /**\n   *  Create a filter that transforms the input image by 'matrix'. This matrix transforms the\n   *  local space, which means it effectively happens prior to any transformation coming from the\n   *  SkCanvas initiating the filtering.\n   *  @param matrix     The matrix to apply to the original content.\n   *  @param filterMode The filter mode to use when sampling the image @default FilterMode.Nearest\n   *  @param mipmap     The mipmap mode to use when sampling the image @default MipmapMode.None\n   *  @param input      The image filter to transform, or null to use the source image.\n   */\n  MakeMatrixTransform(\n    matrix: SkMatrix,\n    filterMode?: FilterMode,\n    mipmap?: MipmapMode,\n    input?: SkImageFilter | null\n  ): SkImageFilter;\n\n  /**\n   *  Create a filter that merges filters together by drawing their results in order\n   *  with src-over blending.\n   *  @param filters  The input filter array to merge. Any null\n   *                  filter pointers will use the source bitmap instead.\n   *  @param cropRect Optional rectangle that crops all input filters and the output.\n   */\n  MakeMerge(\n    filters: Array<SkImageFilter | null>,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n\n  /**\n   *  Create a filter that produces the SkPicture as its output, clipped to both 'targetRect' and\n   *  the picture's internal cull rect.\n   *\n   *  If 'pic' is null, the returned image filter produces transparent black.\n   *\n   *  @param picture    The picture that is drawn for the filter output.\n   *  @param targetRect The drawing region for the picture. If null, the picture's bounds are used.\n   */\n  MakePicture(picture: SkPicture, targetRect?: SkRect | null): SkImageFilter;\n\n  /**\n   *  Create a filter that fills the output with the per-pixel evaluation of the SkShader produced\n   *  by the SkRuntimeEffectBuilder. The shader is defined in the image filter's local coordinate\n   *  system, so it will automatically be affected by SkCanvas' transform.\n   *\n   *  This requires a GPU backend or SkSL to be compiled in.\n   *\n   *  @param builder          The builder used to produce the runtime shader, that will in turn\n   *                          fill the result image\n   *  @param sampleRadius     defines the sampling radius of 'childShaderName' relative to\n   *                          the runtime shader produced by 'builder'.\n   *                          If greater than 0, the coordinate passed to childShader.eval() will\n   *                          be up to 'sampleRadius' away (maximum absolute offset in 'x' or 'y')\n   *                          from the coordinate passed into the runtime shader.\n   *  @param childShaderNames The names of the child shaders defined in the builder that will be\n   *                          bound to the input params (or the source image if the input param\n   *                          is null). If any name is null, or appears more than once, factory\n   *                          fails and returns nullptr.\n   *  @param inputs           The image filters that will be provided as input to the runtime\n   *                          shader. If any are null, the implicit source image is used instead.\n   */\n  MakeRuntimeShaderWithChildren: (\n    builder: SkRuntimeShaderBuilder,\n    sampleRadius: number,\n    childShaderNames: string[],\n    inputs: Array<SkImageFilter | null>\n  ) => SkImageFilter;\n\n  /**\n   *  Create a tile image filter.\n   *  @param src   Defines the pixels to tile\n   *  @param dst   Defines the pixel region that the tiles will be drawn to\n   *  @param input The input that will be tiled, if null the source bitmap is used instead.\n   */\n  MakeTile(\n    src: SkRect,\n    dst: SkRect,\n    input?: SkImageFilter | null\n  ): SkImageFilter;\n\n  /**\n   *  Create a filter that calculates the diffuse illumination from a distant light source,\n   *  interpreting the alpha channel of the input as the height profile of the surface (to\n   *  approximate normal vectors).\n   *  @param direction    The direction to the distance light.\n   *  @param lightColor   The color of the diffuse light source.\n   *  @param surfaceScale Scale factor to transform from alpha values to physical height.\n   *  @param kd           Diffuse reflectance coefficient.\n   *  @param input        The input filter that defines surface normals (as alpha), or uses the\n   *                      source bitmap when null.\n   *  @param cropRect     Optional rectangle that crops the input and output.\n   */\n  MakeDistantLitDiffuse(\n    direction: SkPoint3,\n    lightColor: SkColor,\n    surfaceScale: number,\n    kd: number,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n\n  /**\n   *  Create a filter that calculates the diffuse illumination from a point light source, using\n   *  alpha channel of the input as the height profile of the surface (to approximate normal\n   *  vectors).\n   *  @param location     The location of the point light.\n   *  @param lightColor   The color of the diffuse light source.\n   *  @param surfaceScale Scale factor to transform from alpha values to physical height.\n   *  @param kd           Diffuse reflectance coefficient.\n   *  @param input        The input filter that defines surface normals (as alpha), or uses the\n   *                      source bitmap when null.\n   *  @param cropRect     Optional rectangle that crops the input and output.\n   */\n  MakePointLitDiffuse(\n    location: SkPoint3,\n    lightColor: SkColor,\n    surfaceScale: number,\n    kd: number,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n\n  /**\n   *  Create a filter that calculates the diffuse illumination from a spot light source, using\n   *  alpha channel of the input as the height profile of the surface (to approximate normal\n   *  vectors). The spot light is restricted to be within 'cutoffAngle' of the vector between\n   *  the location and target.\n   *  @param location        The location of the spot light.\n   *  @param target          The location that the spot light is point towards\n   *  @param falloffExponent Exponential falloff parameter for illumination outside of cutoffAngle\n   *  @param cutoffAngle     Maximum angle from lighting direction that receives full light\n   *  @param lightColor      The color of the diffuse light source.\n   *  @param surfaceScale    Scale factor to transform from alpha values to physical height.\n   *  @param kd              Diffuse reflectance coefficient.\n   *  @param input           The input filter that defines surface normals (as alpha), or uses the\n   *                         source bitmap when null.\n   *  @param cropRect        Optional rectangle that crops the input and output.\n   */\n  MakeSpotLitDiffuse(\n    location: SkPoint3,\n    target: SkPoint3,\n    falloffExponent: number,\n    cutoffAngle: number,\n    lightColor: SkColor,\n    surfaceScale: number,\n    kd: number,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n\n  /**\n   *  Create a filter that calculates the specular illumination from a distant light source,\n   *  interpreting the alpha channel of the input as the height profile of the surface (to\n   *  approximate normal vectors).\n   *  @param direction    The direction to the distance light.\n   *  @param lightColor   The color of the specular light source.\n   *  @param surfaceScale Scale factor to transform from alpha values to physical height.\n   *  @param ks           Specular reflectance coefficient.\n   *  @param shininess    The specular exponent determining how shiny the surface is.\n   *  @param input        The input filter that defines surface normals (as alpha), or uses the\n   *                      source bitmap when null.\n   *  @param cropRect     Optional rectangle that crops the input and output.\n   */\n  MakeDistantLitSpecular(\n    direction: SkPoint3,\n    lightColor: SkColor,\n    surfaceScale: number,\n    ks: number,\n    shininess: number,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n\n  /**\n   *  Create a filter that calculates the specular illumination from a point light source, using\n   *  alpha channel of the input as the height profile of the surface (to approximate normal\n   *  vectors).\n   *  @param location     The location of the point light.\n   *  @param lightColor   The color of the specular light source.\n   *  @param surfaceScale Scale factor to transform from alpha values to physical height.\n   *  @param ks           Specular reflectance coefficient.\n   *  @param shininess    The specular exponent determining how shiny the surface is.\n   *  @param input        The input filter that defines surface normals (as alpha), or uses the\n   *                      source bitmap when null.\n   *  @param cropRect     Optional rectangle that crops the input and output.\n   */\n  MakePointLitSpecular(\n    location: SkPoint3,\n    lightColor: SkColor,\n    surfaceScale: number,\n    ks: number,\n    shininess: number,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n\n  /**\n   *  Create a filter that calculates the specular illumination from a spot light source, using\n   *  alpha channel of the input as the height profile of the surface (to approximate normal\n   *  vectors). The spot light is restricted to be within 'cutoffAngle' of the vector between\n   *  the location and target.\n   *  @param location        The location of the spot light.\n   *  @param target          The location that the spot light is point towards\n   *  @param falloffExponent Exponential falloff parameter for illumination outside of cutoffAngle\n   *  @param cutoffAngle     Maximum angle from lighting direction that receives full light\n   *  @param lightColor      The color of the specular light source.\n   *  @param surfaceScale    Scale factor to transform from alpha values to physical height.\n   *  @param ks              Specular reflectance coefficient.\n   *  @param shininess       The specular exponent determining how shiny the surface is.\n   *  @param input           The input filter that defines surface normals (as alpha), or uses the\n   *                         source bitmap when null.\n   *  @param cropRect        Optional rectangle that crops the input and output.\n   */\n  MakeSpotLitSpecular(\n    location: SkPoint3,\n    target: SkPoint3,\n    falloffExponent: number,\n    cutoffAngle: number,\n    lightColor: SkColor,\n    surfaceScale: number,\n    ks: number,\n    shininess: number,\n    input?: SkImageFilter | null,\n    cropRect?: SkRect | null\n  ): SkImageFilter;\n}\n\nexport type SkPoint3 = {\n  x: number;\n  y: number;\n  z: number;\n};\n"],"mappings":";;;;;;IAYYA,YAAY,GAAAC,OAAA,CAAAD,YAAA,0BAAZA,YAAY;EAAZA,YAAY,CAAZA,YAAY;EAAZA,YAAY,CAAZA,YAAY;EAAZA,YAAY,CAAZA,YAAY;EAAZA,YAAY,CAAZA,YAAY;EAAA,OAAZA,YAAY;AAAA","ignoreList":[]}